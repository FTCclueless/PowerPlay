package org.firstinspires.ftc.teamcode.OpModes;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;

import org.firstinspires.ftc.teamcode.Controllables.Location;
import org.firstinspires.ftc.teamcode.ReneBase;
import org.firstinspires.ftc.teamcode.Trajectories.ThreePointSpline;
import org.firstinspires.ftc.teamcode.Trajectories.TwoPointSpline;

import java.util.ArrayList;

@Autonomous
public class ReneAuto extends ReneBase {

    @Override
    public void runOpMode()
    {
        telemetry.addData("Initializing: ", "Started");
        telemetry.update();
        //Initialize the motors. Basically just define the motors as their ports and names
        initMotors();

        //Initialize the location object which follows the position of the robot and set the robot to be at (0,0). You can change where the robot will be initialized and what angle it is facing
        initLocation(0, 0, 0);

        //Initialize the odometry object to track the robot
        initOdometry();

        telemetry.addData("Initializing: ", "Done");
        telemetry.update();

        waitForStart();
        time.reset();

        /*
         * Prints the current location of the robot using telemetry
         */
        printLocation();

        /*
         * Prints the raw encoder values on the robot
         */
        printEncoderValues();

        /*
         * Resets the odometry object so that the robot's current location is (0,0) facing angle 0
         */
        resetOdo();

        /*
         * This method drives to the point on the field which is (0,30) measured in inches
         * The x is the x-coordinate of the target
         * The y is the y-coordinate of the target
         * The maxPow is the maximum power allowed for the motors to use (you typically want this to be 1 so that it will go as fast as possible)
         * The allowance is the radius of a circle within which the robot will stop. For instance, it will currently stop when it is within 1 inch of the target
         */
        driveToPointLoop(0, 30, 1, 1);

        /*
         * Make an array list of locations you would like to travel to using the Pure Pursuit algorithm
         * This array list can be as long as you would like
         */
        ArrayList<Location> path = new ArrayList<>();
        path.add(new Location (20, 20));
        path.add(new Location (40, 70));
        path.add(new Location (0, 0));
        path.add(new Location (-30, 20));

        /*
         * Follow the path you created. The path must be an array list of location objects, that is just how I decided to implement all the target points.
         * The method will follow the lines generated by the points using the Pure Pursuit algorithm
         * The circle radius is the radius around the robot that the robot will travel to measured in inches
         * The timeout defines the time at which the robot will stop if the whole process exceeds this time
         */
        purePursuit(path, 10, 20);

        /*
         * I wouldn't recommend using this. You may want to alter it so that it works for you but it assumes that the robot starts at 0,0
         */
        MotionProfilingDriveToPoint(new Location(20, 30), 4, 1);

        /*
         * Create a straight line spline based on 2 points; the current location of the robot (odo.loc) and the target location (0,20)
         * The total time is the time it will take to follow the spline
         */
        TwoPointSpline twoPointSpline = new TwoPointSpline(odo.loc, new Location(0, 20), 2);

        /*
         * Follow the spline you just created with these values as the constants to multiply by to get the powers to send to the robot
         * I found these to work for Rene (other than the angle, hasn't been tested) but you should figure out what works for you
         */
        followMotionProfile2D(twoPointSpline, 0.1, -0.06, -0.005, 0.1);

        /*
         * Create a 3 point spline to follow. The first point should be the robot's current location (odo.loc)
         * The total time is the time it will take to follow the spline
         * C is a variable that you will have to play around with to get right. It doesn't have any great definition but I would recommend checking out this desmos graph
         * It plots the points you want to travel to (with the first point at the origin - keep that in mind). Using that you can play around with the C value to
         * See what you think it should be for your spline
         * https://www.desmos.com/calculator/il75hjsnew
         */
        ThreePointSpline threePointSpline = new ThreePointSpline(odo.loc, new Location(40, 40), new Location(30, 50), 5, 1);

        /*
         * Follow the spline you just created with these values as the constants to multiply by to get the powers to send to the robot
         * I found these to work for Rene (other than the angle, hasn't been tested) but you should figure out what works for you
         */
        followMotionProfile2D(threePointSpline, 0.1, -0.06, -0.005, 0.1);
    }


}
